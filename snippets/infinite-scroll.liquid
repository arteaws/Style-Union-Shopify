<infinite-scroll data-next="{{ next_page }}" data-page-size="{{ page_size }}" data-end-text="{{ end_text }}">
  {% if page_size > 1 %}
    <div class="loadingBox">
      <span id="loading_1" class="loadingScroll">&nbsp</span>
      <span id="loading_2" class="loadingScroll">&nbsp</span>
      <span id="loading_3" class="loadingScroll">&nbsp</span>
      <span id="loading_4" class="loadingScroll">&nbsp</span>
      <span id="loading_5" class="loadingScroll">&nbsp</span>
      <span id="loading_6" class="loadingScroll">&nbsp</span>
      <span id="loading_7" class="loadingScroll">&nbsp</span>
      <span id="loading_8" class="loadingScroll">&nbsp</span>
    </div>
  {% endif %}
</infinite-scroll>
<div class="scrollToTopButton">Scroll To Top</div>
<style>
  .collection__page.row.grid__wrapper{
    position:relative;
  }
  infinite-scroll {
    position: absolute;
    width: 100%;
    font-weight: 600;
    bottom: 0;
    left: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
  }
  .loadingBox {
    position: relative;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 28px;
    margin: auto;
  }
  .loadingScroll {
    position: relative;
    background-color: rgb(0, 0, 0);
    width: 28px;
    height: 28px;
    margin: 0 1px;
    animation-name: loading_animation;
    -o-animation-name: loading_animation;
    -ms-animation-name: loading_animation;
    -webkit-animation-name: loading_animation;
    -moz-animation-name: loading_animation;
    animation-duration: 0.8s;
    -o-animation-duration: 0.8s;
    -ms-animation-duration: 0.8s;
    -webkit-animation-duration: 0.8s;
    -moz-animation-duration: 0.8s;
    animation-iteration-count: infinite;
    -o-animation-iteration-count: infinite;
    -ms-animation-iteration-count: infinite;
    -webkit-animation-iteration-count: infinite;
    -moz-animation-iteration-count: infinite;
    animation-direction: normal;
    -o-animation-direction: normal;
    -ms-animation-direction: normal;
    -webkit-animation-direction: normal;
    -moz-animation-direction: normal;
    transform: scale(0.3);
    -o-transform: scale(0.3);
    -ms-transform: scale(0.3);
    -webkit-transform: scale(0.3);
    -moz-transform: scale(0.3);
  }
  .scrollToTopButton {
    position: fixed;
    bottom: 20px;
    right: 149px;
    background: #ececec;
    padding: 5px 10px;
    z-index: 1;
    cursor: pointer;
    border-radius: 5px;
  }
  
  #loading_1 {
    animation-delay: 0.1s;
    -o-animation-delay: 0.1s;
    -ms-animation-delay: 0.1s;
    -webkit-animation-delay: 0.1s;
    -moz-animation-delay: 0.1s;
  }
  #loading_2 {
    animation-delay: 0.2s;
    -o-animation-delay: 0.2s;
    -ms-animation-delay: 0.2s;
    -webkit-animation-delay: 0.2s;
    -moz-animation-delay: 0.2s;
  }
  #loading_3 {
    animation-delay: 0.3s;
    -o-animation-delay: 0.3s;
    -ms-animation-delay: 0.3s;
    -webkit-animation-delay: 0.3s;
    -moz-animation-delay: 0.3s;
  }
  #loading_4 {
    animation-delay: 0.4s;
    -o-animation-delay: 0.4s;
    -ms-animation-delay: 0.4s;
    -webkit-animation-delay: 0.4s;
    -moz-animation-delay: 0.4s;
  }
  #loading_5 {
    animation-delay: 0.5s;
    -o-animation-delay: 0.5s;
    -ms-animation-delay: 0.5s;
    -webkit-animation-delay: 0.5s;
    -moz-animation-delay: 0.5s;
  }
  #loading_6 {
    animation-delay: 0.6s;
    -o-animation-delay: 0.6s;
    -ms-animation-delay: 0.6s;
    -webkit-animation-delay: 0.6s;
    -moz-animation-delay: 0.6s;
  }
  #loading_7 {
    animation-delay: 0.7s;
    -o-animation-delay: 0.7s;
    -ms-animation-delay: 0.7s;
    -webkit-animation-delay: 0.7s;
    -moz-animation-delay: 0.7s;
  }
  #loading_8 {
    animation-delay: 0.8s;
    -o-animation-delay: 0.8s;
    -ms-animation-delay: 0.8s;
    -webkit-animation-delay: 0.8s;
    -moz-animation-delay: 0.8s;
  }

  [class^="pagination"], [class^="Pagination"], .pagination {
    display: none !important;
  }

  .js .features--show-element-staggering .ProductList--grid div.ProductItem {
    visibility: visible;
  }

  .js .product-card[reveal-on-scroll="true"] {
    opacity: 1;
  }

  @keyframes loading_animation {
    0% {
      transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-o-keyframes loading_animation {
    0% {
      -o-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -o-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-ms-keyframes loading_animation {
    0% {
      -ms-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -ms-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-webkit-keyframes loading_animation {
    0% {
      -webkit-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -webkit-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-moz-keyframes loading_animation {
    0% {
      -moz-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -moz-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
</style>

<script>
  class InfiniteScroll extends HTMLElement {
    constructor() {
      super();
      this.initGrid();
      this.init();
      this.page = 1; // Keep original logic
      this.isLoading = false;
      this.loadedProductIds = new Set(); // Track loaded product IDs
      this.scrollToTopBtn = document.querySelector(".scrollToTopButton");
      if (this.scrollToTopBtn) {
        this.scrollToTopBtn.addEventListener("click", this.scrollToTopFx.bind(this));
      }
      
      // Track existing products on page load
      this.trackExistingProducts();
    }
   
    initGrid() {
      const gridOptions = [".ProductListWrapper", "#main-collection-product-grid", "#product-grid", ".product-list"];
      for (let gridName of gridOptions) {
        let grid = document.querySelector(gridName);
        if (grid) {
          this.gridName = gridName;
          this.gridContainer = grid;
          console.log("Grid container found:", gridName);
          break;
        }
      }
      
      if (!this.gridContainer) {
        console.error("No grid container found!");
      }
    }
    
    trackExistingProducts() {
      if (this.gridContainer) {
        const existingProducts = this.gridContainer.querySelectorAll('[data-product-id]');
        existingProducts.forEach(product => {
          const productId = product.getAttribute('data-product-id');
          if (productId) {
            this.loadedProductIds.add(productId);
          }
        });
        console.log(`Tracked ${this.loadedProductIds.size} existing products`);
      }
    }
   
    init() {
      const observer = new IntersectionObserver(this.revealItem.bind(this), {
        root: null,
        threshold: 0.2,
        rootMargin: '200px'
      });
      observer.observe(this);
      console.log("Intersection observer initialized");
    }
   
    fetchNextPage(pageNum) {
      if (this.isLoading || pageNum > this.dataset.pageSize) {
        console.log("Already loading or reached max pages");
        return;
      }
      
      this.isLoading = true;
      console.log(`Fetching page ${pageNum}`);
      
      if (pageNum <= this.dataset.pageSize) {
        // Use original URL construction method
        const baseUrl = `${window.location.origin}${this.dataset.next}`;
        const url = new URL(baseUrl);
        url.searchParams.set("page", pageNum);
        const requestUrl = url.href;
        
        console.log("Request URL:", requestUrl);
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        
        fetch(requestUrl, { 
          method: "GET", 
          headers: { 
            "Content-Type": "text/html",
            "Cache-Control": "no-cache"
          },
          signal: controller.signal
        })
          .then((response) => {
            clearTimeout(timeoutId);
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.text();
          })
          .then((html) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");
            const newGrid = doc.querySelector(this.gridName);
            
            if (newGrid && newGrid.innerHTML) {
              // Filter out products that are already loaded
              const newProducts = newGrid.querySelectorAll('[data-product-id]');
              let addedCount = 0;
              
              newProducts.forEach(product => {
                const productId = product.getAttribute('data-product-id');
                if (productId && !this.loadedProductIds.has(productId)) {
                  this.gridContainer.insertAdjacentHTML("beforeend", product.outerHTML);
                  this.loadedProductIds.add(productId);
                  addedCount++;
                }
              });
              
              console.log(`Added ${addedCount} new unique products`);
            }
            this.isLoading = false;
          })
          .catch((error) => {
            clearTimeout(timeoutId);
            console.error("Fetch error:", error);
            this.isLoading = false;
          });
      }
      
      if (pageNum == this.dataset.pageSize) {
        this.innerHTML = `<h2>${this.dataset.endText}</h2>`;
      }
    }
    
    revealItem(entries, observer) {
      const [entry] = entries;
      console.log("Intersection observed:", entry.isIntersecting, "Loading:", this.isLoading);
      
      if (!entry.isIntersecting || this.isLoading) return;
      
      if (entry.target) {
        this.page++;
        console.log("Loading page:", this.page);
        setTimeout(() => {
          this.fetchNextPage(this.page);
        }, 100);
      }
      
      if (this.page == this.dataset.pageSize) {
        observer.unobserve(entry.target);
      }
    }
    
    scrollToTopFx(e) {
      document.body.scrollTop = 0;
      document.documentElement.scrollTop = 0;
      if (e.currentTarget) {
        e.currentTarget.style.display = "none";
      }
    }
  }
  
  customElements.define("infinite-scroll", InfiniteScroll);
</script>