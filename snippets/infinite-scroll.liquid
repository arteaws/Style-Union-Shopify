<infinite-scroll data-next="{{ next_page }}" data-page-size="{{ page_size }}" data-end-text="{{ end_text }}">
  {% if page_size > 1 %}
    <div class="loadingBox">
      <span id="loading_1" class="loadingScroll">&nbsp</span>
      <span id="loading_2" class="loadingScroll">&nbsp</span>
      <span id="loading_3" class="loadingScroll">&nbsp</span>
      <span id="loading_4" class="loadingScroll">&nbsp</span>
      <span id="loading_5" class="loadingScroll">&nbsp</span>
      <span id="loading_6" class="loadingScroll">&nbsp</span>
      <span id="loading_7" class="loadingScroll">&nbsp</span>
      <span id="loading_8" class="loadingScroll">&nbsp</span>
    </div>
  {% endif %}
</infinite-scroll>
<div class="scrollToTopButton">Scroll To Top</div>
<style>
  /* Your existing CSS remains the same */
</style>

<script>
  class InfiniteScroll extends HTMLElement {
    constructor() {
      super();
      this.initGrid();
      this.init();
      this.nextPage = 2; // Start from page 2 (since page 1 is already loaded)
      this.isLoading = false;
      this.hasMorePages = true;
      this.loadedProductIds = new Set();
      this.scrollToTopBtn = document.querySelector(".scrollToTopButton");
      
      if (this.scrollToTopBtn) {
        this.scrollToTopBtn.addEventListener("click", this.scrollToTopFx.bind(this));
      }
      
      this.trackExistingProducts();
    }
   
    initGrid() {
      const gridOptions = [".ProductListWrapper", "#main-collection-product-grid", "#product-grid", ".product-list"];
      for (let gridName of gridOptions) {
        let grid = document.querySelector(gridName);
        if (grid) {
          this.gridName = gridName;
          this.gridContainer = grid;
          break;
        }
      }
      
      if (!this.gridContainer) {
        console.error("No grid container found!");
      }
    }
    
    trackExistingProducts() {
      if (this.gridContainer) {
        const existingProducts = this.gridContainer.querySelectorAll('[data-product-id]');
        existingProducts.forEach(product => {
          const productId = product.getAttribute('data-product-id');
          if (productId) {
            this.loadedProductIds.add(productId);
          }
        });
      }
    }
   
    init() {
      this.observer = new IntersectionObserver(this.handleIntersection.bind(this), {
        root: null,
        threshold: 0.1,
        rootMargin: '200px'
      });
      this.observer.observe(this);
    }
   
    handleIntersection(entries) {
      const [entry] = entries;
      
      if (!entry.isIntersecting || this.isLoading || !this.hasMorePages) return;
      
      this.loadMore();
    }
    
    loadMore() {
      if (this.nextPage > parseInt(this.dataset.pageSize)) {
        this.hasMorePages = false;
        this.showEndText();
        return;
      }
      
      this.isLoading = true;
      
      const baseUrl = `${window.location.origin}${this.dataset.next}`;
      const url = new URL(baseUrl);
      url.searchParams.set("page", this.nextPage);
      
      fetch(url.href, { 
        headers: { "X-Requested-With": "XMLHttpRequest" }
      })
        .then(response => {
          if (!response.ok) throw new Error('Network response was not ok');
          return response.text();
        })
        .then(html => {
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, "text/html");
          const newGrid = doc.querySelector(this.gridName);
          
          if (newGrid && newGrid.innerHTML) {
            const newProducts = newGrid.querySelectorAll('[data-product-id]');
            let addedCount = 0;
            
            newProducts.forEach(product => {
              const productId = product.getAttribute('data-product-id');
              if (productId && !this.loadedProductIds.has(productId)) {
                this.gridContainer.insertAdjacentHTML("beforeend", product.outerHTML);
                this.loadedProductIds.add(productId);
                addedCount++;
              }
            });
            
            if (addedCount > 0) {
              this.nextPage++;
            } else {
              this.hasMorePages = false;
              this.showEndText();
            }
          } else {
            this.hasMorePages = false;
            this.showEndText();
          }
        })
        .catch(error => {
          console.error('Error loading more products:', error);
        })
        .finally(() => {
          this.isLoading = false;
        });
    }
    
    showEndText() {
      if (this.dataset.endText) {
        this.innerHTML = `<div class="end-text">${this.dataset.endText}</div>`;
      }
      if (this.observer) {
        this.observer.unobserve(this);
      }
    }
    
    scrollToTopFx(e) {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }
  }
  
  customElements.define("infinite-scroll", InfiniteScroll);
</script>