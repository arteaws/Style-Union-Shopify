<infinite-scroll data-next="{{ next_page }}" data-page-size="{{ page_size }}" data-end-text="{{ end_text }}">
  {% if page_size > 1 %}
    <div class="loadingBox">
      <span id="loading_1" class="loadingScroll">&nbsp</span>
      <span id="loading_2" class="loadingScroll">&nbsp</span>
      <span id="loading_3" class="loadingScroll">&nbsp</span>
      <span id="loading_4" class="loadingScroll">&nbsp</span>
      <span id="loading_5" class="loadingScroll">&nbsp</span>
      <span id="loading_6" class="loadingScroll">&nbsp</span>
      <span id="loading_7" class="loadingScroll">&nbsp</span>
      <span id="loading_8" class="loadingScroll">&nbsp</span>
    </div>
  {% endif %}
</infinite-scroll>
<div class="scrollToTopButton">Scroll To Top</div>
<style>
  .collection__page.row.grid__wrapper{
    position:relative;
  }
  infinite-scroll {
    position: absolute;
    width: 100%;
    font-weight: 600;
    bottom: 0;
    left: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
  }
  .loadingBox {
    position: relative;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 28px;
    margin: auto;
  }
  .loadingScroll {
    position: relative;
    background-color: rgb(0, 0, 0);
    width: 28px;
    height: 28px;
    margin: 0 1px;
    animation-name: loading_animation;
    -o-animation-name: loading_animation;
    -ms-animation-name: loading_animation;
    -webkit-animation-name: loading_animation;
    -moz-animation-name: loading_animation;
    animation-duration: 0.8s;
    -o-animation-duration: 0.8s;
    -ms-animation-duration: 0.8s;
    -webkit-animation-duration: 0.8s;
    -moz-animation-duration: 0.8s;
    animation-iteration-count: infinite;
    -o-animation-iteration-count: infinite;
    -ms-animation-iteration-count: infinite;
    -webkit-animation-iteration-count: infinite;
    -moz-animation-iteration-count: infinite;
    animation-direction: normal;
    -o-animation-direction: normal;
    -ms-animation-direction: normal;
    -webkit-animation-direction: normal;
    -moz-animation-direction: normal;
    transform: scale(0.3);
    -o-transform: scale(0.3);
    -ms-transform: scale(0.3);
    -webkit-transform: scale(0.3);
    -moz-transform: scale(0.3);
  }
  .scrollToTopButton {
    position: fixed;
    bottom: 20px;
    right: 149px;
    background: #ececec;
    padding: 5px 10px;
    z-index: 1;
    cursor: pointer;
    border-radius: 5px;
  }
  
  #loading_1 {
    animation-delay: 0.1s;
    -o-animation-delay: 0.1s;
    -ms-animation-delay: 0.1s;
    -webkit-animation-delay: 0.1s;
    -moz-animation-delay: 0.1s;
  }
  #loading_2 {
    animation-delay: 0.2s;
    -o-animation-delay: 0.2s;
    -ms-animation-delay: 0.2s;
    -webkit-animation-delay: 0.2s;
    -moz-animation-delay: 0.2s;
  }
  #loading_3 {
    animation-delay: 0.3s;
    -o-animation-delay: 0.3s;
    -ms-animation-delay: 0.3s;
    -webkit-animation-delay: 0.3s;
    -moz-animation-delay: 0.3s;
  }
  #loading_4 {
    animation-delay: 0.4s;
    -o-animation-delay: 0.4s;
    -ms-animation-delay: 0.4s;
    -webkit-animation-delay: 0.4s;
    -moz-animation-delay: 0.4s;
  }
  #loading_5 {
    animation-delay: 0.5s;
    -o-animation-delay: 0.5s;
    -ms-animation-delay: 0.5s;
    -webkit-animation-delay: 0.5s;
    -moz-animation-delay: 0.5s;
  }
  #loading_6 {
    animation-delay: 0.6s;
    -o-animation-delay: 0.6s;
    -ms-animation-delay: 0.6s;
    -webkit-animation-delay: 0.6s;
    -moz-animation-delay: 0.6s;
  }
  #loading_7 {
    animation-delay: 0.7s;
    -o-animation-delay: 0.7s;
    -ms-animation-delay: 0.7s;
    -webkit-animation-delay: 0.7s;
    -moz-animation-delay: 0.7s;
  }
  #loading_8 {
    animation-delay: 0.8s;
    -o-animation-delay: 0.8s;
    -ms-animation-delay: 0.8s;
    -webkit-animation-delay: 0.8s;
    -moz-animation-delay: 0.8s;
  }

  [class^="pagination"], [class^="Pagination"], .pagination {
    display: none !important;
  }

  .js .features--show-element-staggering .ProductList--grid div.ProductItem {
    visibility: visible;
  }

  .js .product-card[reveal-on-scroll="true"] {
    opacity: 1;
  }

  @keyframes loading_animation {
    0% {
      transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-o-keyframes loading_animation {
    0% {
      -o-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -o-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-ms-keyframes loading_animation {
    0% {
      -ms-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -ms-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-webkit-keyframes loading_animation {
    0% {
      -webkit-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -webkit-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-moz-keyframes loading_animation {
    0% {
      -moz-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -moz-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
</style>

<script>
  class InfiniteScroll extends HTMLElement {
    constructor() {
      super();
      this.initGrid();
      this.init();
      this.currentPage = 1; // Start from page 1 (first page is already loaded)
      this.isLoading = false;
      this.loadedProducts = new Set(); // Track loaded products to prevent duplicates
      this.scrollToTopBtn = document.querySelector(".scrollToTopButton");
      if (this.scrollToTopBtn) {
        this.scrollToTopBtn.addEventListener("click", this.scrollToTopFx.bind(this));
      }
    }
   
    initGrid() {
      const gridOptions = [".ProductListWrapper", "#main-collection-product-grid", "#product-grid", ".product-list"];
      for (let gridName of gridOptions) {
        let grid = document.querySelector(gridName);
        if (grid) {
          this.gridName = gridName;
          this.gridContainer = grid;
          break;
        }
      }
      
      // Track initially loaded products
      this.trackExistingProducts();
    }
    
    trackExistingProducts() {
      if (this.gridContainer) {
        // Look for products with various possible selectors
        const existingProducts = this.gridContainer.querySelectorAll('.js-product-listing, .product-index, .ProductItem, [data-product-id]');
        existingProducts.forEach(product => {
          const productId = product.getAttribute('data-product-id') || 
                          product.querySelector('[data-product-id]')?.getAttribute('data-product-id');
          if (productId) {
            this.loadedProducts.add(productId);
          }
        });
        console.log(`Tracked ${this.loadedProducts.size} existing products`);
      }
    }
   
    init() {
      const observer = new IntersectionObserver(this.revealItem.bind(this), {
        root: null,
        threshold: 0.2,
        rootMargin: '200px'
      });
      observer.observe(this);
    }
   
    fetchNextPage() {
      // Prevent multiple simultaneous requests
      if (this.isLoading || this.currentPage >= this.dataset.pageSize) {
        return;
      }
      
      this.isLoading = true;
      this.currentPage++; // Increment to next page
      
      // Get current URL and modify it for next page
      const currentUrl = new URL(window.location.href);
      currentUrl.searchParams.set("page", this.currentPage);
      const nextPageUrl = currentUrl.href;
      
      console.log(`Loading page ${this.currentPage} from: ${nextPageUrl}`);
      
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      fetch(nextPageUrl, { 
        method: "GET", 
        headers: { 
          "Content-Type": "text/html",
          "Cache-Control": "no-cache"
        },
        signal: controller.signal
      })
        .then((response) => {
          clearTimeout(timeoutId);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.text();
        })
        .then((html) => {
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, "text/html");
          const newGrid = doc.querySelector(this.gridName);
          
          if (newGrid && newGrid.innerHTML.trim()) {
            // Extract new products and filter out duplicates
            const newProducts = newGrid.querySelectorAll('[data-product-id]');
            let addedCount = 0;
            
            newProducts.forEach(product => {
              const productId = product.getAttribute('data-product-id');
              if (productId && !this.loadedProducts.has(productId)) {
                this.gridContainer.appendChild(product.cloneNode(true));
                this.loadedProducts.add(productId);
                addedCount++;
              }
            });
            
            console.log(`Added ${addedCount} new products from page ${this.currentPage}`);
            
            // If no new products were added, we might have reached the end
            if (addedCount === 0) {
              this.innerHTML = `<h2>${this.dataset.endText}</h2>`;
              return;
            }
          } else {
            // No more products available
            this.innerHTML = `<h2>${this.dataset.endText}</h2>`;
            return;
          }
          
          this.isLoading = false;
        })
        .catch((error) => {
          clearTimeout(timeoutId);
          console.error("Error loading next page:", error);
          this.isLoading = false;
          
          // If it's an abort error, we might have reached the end
          if (error.name === 'AbortError') {
            this.innerHTML = `<h2>${this.dataset.endText}</h2>`;
          }
        });
      
      // Check if we've reached the last page
      if (this.currentPage >= this.dataset.pageSize) {
        setTimeout(() => {
          this.innerHTML = `<h2>${this.dataset.endText}</h2>`;
        }, 2000);
      }
    }
    
    revealItem(entries, observer) {
      const [entry] = entries;
      if (!entry.isIntersecting || this.isLoading) return;
      
      if (entry.target && this.currentPage < parseInt(this.dataset.pageSize)) {
        console.log('Intersection observed, loading next page...');
        setTimeout(() => {
          this.fetchNextPage();
        }, 100);
      }
      
      if (this.currentPage >= parseInt(this.dataset.pageSize)) {
        observer.unobserve(entry.target);
        this.innerHTML = `<h2>${this.dataset.endText}</h2>`;
      }
    }
    
    scrollToTopFx(e) {
      document.body.scrollTop = 0;
      document.documentElement.scrollTop = 0;
      if (e.currentTarget) {
        e.currentTarget.style.display = "none";
      }
    }
  }
  
  customElements.define("infinite-scroll", InfiniteScroll);
</script>