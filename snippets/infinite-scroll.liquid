<infinite-scroll data-next="{{ next_page }}" data-page-size="{{ page_size }}" data-end-text="{{ end_text }}">
  {% if page_size > 1 %}
    <div class="loadingBox">
      <span id="loading_1" class="loadingScroll">&nbsp</span>
      <span id="loading_2" class="loadingScroll">&nbsp</span>
      <span id="loading_3" class="loadingScroll">&nbsp</span>
      <span id="loading_4" class="loadingScroll">&nbsp</span>
      <span id="loading_5" class="loadingScroll">&nbsp</span>
      <span id="loading_6" class="loadingScroll">&nbsp</span>
      <span id="loading_7" class="loadingScroll">&nbsp</span>
      <span id="loading_8" class="loadingScroll">&nbsp</span>
    </div>
  {% endif %}
</infinite-scroll>
<div class="scrollToTopButton">Scroll To Top</div>
<style>
  .collection__page.row.grid__wrapper{
    position:relative;
  }
  infinite-scroll {
    position: absolute;
    width: 100%;
    font-weight: 600;
    bottom: 0;
    left: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease; /* Faster transition */
  }
  .loadingBox {
    position: relative;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 28px;
    margin: auto;
  }
  .loadingScroll {
    position: relative;
    background-color: rgb(0, 0, 0);
    width: 28px;
    height: 28px;
    margin: 0 1px;
    animation-name: loading_animation;
    -o-animation-name: loading_animation;
    -ms-animation-name: loading_animation;
    -webkit-animation-name: loading_animation;
    -moz-animation-name: loading_animation;
    animation-duration: 0.8s; /* Faster animation */
    -o-animation-duration: 0.8s;
    -ms-animation-duration: 0.8s;
    -webkit-animation-duration: 0.8s;
    -moz-animation-duration: 0.8s;
    animation-iteration-count: infinite;
    -o-animation-iteration-count: infinite;
    -ms-animation-iteration-count: infinite;
    -webkit-animation-iteration-count: infinite;
    -moz-animation-iteration-count: infinite;
    animation-direction: normal;
    -o-animation-direction: normal;
    -ms-animation-direction: normal;
    -webkit-animation-direction: normal;
    -moz-animation-direction: normal;
    transform: scale(0.3);
    -o-transform: scale(0.3);
    -ms-transform: scale(0.3);
    -webkit-transform: scale(0.3);
    -moz-transform: scale(0.3);
  }
  .scrollToTopButton {
    position: fixed;
    bottom: 20px;
    right: 149px;
    background: #ececec;
    padding: 5px 10px;
    z-index: 1;
    cursor: pointer;
    border-radius: 5px;
  }
  /* Faster, staggered animation delays */
  #loading_1 {
    animation-delay: 0.1s;
    -o-animation-delay: 0.1s;
    -ms-animation-delay: 0.1s;
    -webkit-animation-delay: 0.1s;
    -moz-animation-delay: 0.1s;
  }
  #loading_2 {
    animation-delay: 0.2s;
    -o-animation-delay: 0.2s;
    -ms-animation-delay: 0.2s;
    -webkit-animation-delay: 0.2s;
    -moz-animation-delay: 0.2s;
  }
  #loading_3 {
    animation-delay: 0.3s;
    -o-animation-delay: 0.3s;
    -ms-animation-delay: 0.3s;
    -webkit-animation-delay: 0.3s;
    -moz-animation-delay: 0.3s;
  }
  #loading_4 {
    animation-delay: 0.4s;
    -o-animation-delay: 0.4s;
    -ms-animation-delay: 0.4s;
    -webkit-animation-delay: 0.4s;
    -moz-animation-delay: 0.4s;
  }
  #loading_5 {
    animation-delay: 0.5s;
    -o-animation-delay: 0.5s;
    -ms-animation-delay: 0.5s;
    -webkit-animation-delay: 0.5s;
    -moz-animation-delay: 0.5s;
  }
  #loading_6 {
    animation-delay: 0.6s;
    -o-animation-delay: 0.6s;
    -ms-animation-delay: 0.6s;
    -webkit-animation-delay: 0.6s;
    -moz-animation-delay: 0.6s;
  }
  #loading_7 {
    animation-delay: 0.7s;
    -o-animation-delay: 0.7s;
    -ms-animation-delay: 0.7s;
    -webkit-animation-delay: 0.7s;
    -moz-animation-delay: 0.7s;
  }
  #loading_8 {
    animation-delay: 0.8s;
    -o-animation-delay: 0.8s;
    -ms-animation-delay: 0.8s;
    -webkit-animation-delay: 0.8s;
    -moz-animation-delay: 0.8s;
  }

  /* Pristege */
  [class^="pagination"], [class^="Pagination"], .pagination {
    display: none !important;
  }

  .js .features--show-element-staggering .ProductList--grid div.ProductItem {
    visibility: visible;
  }

  .js .product-card[reveal-on-scroll="true"] {
    opacity: 1;
  }

  @keyframes loading_animation {
    0% {
      transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-o-keyframes loading_animation {
    0% {
      -o-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -o-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-ms-keyframes loading_animation {
    0% {
      -ms-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -ms-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-webkit-keyframes loading_animation {
    0% {
      -webkit-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -webkit-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
  @-moz-keyframes loading_animation {
    0% {
      -moz-transform: scale(1);
      background-color: rgb(0, 0, 0);
    }
    100% {
      -moz-transform: scale(0.3);
      background-color: rgb(255, 255, 255);
    }
  }
</style>

<script>
  class InfiniteScroll extends HTMLElement {
  constructor() {
    super();
    this.initGrid();
    this.init();
    this.page = 1;
    this.isLoading = false; // Prevent multiple simultaneous requests
    this.scrollToTopBtn = document.querySelector(".scrollToTopButton");
    this.scrollToTopBtn.addEventListener(
      "click",
      this.scrollToTopFx.bind(this)
    );
  }
 
  initGrid() {
    const gridOptions = [".ProductListWrapper", "#main-collection-product-grid", "#product-grid", ".product-list"];
    for (let gridName of gridOptions) {
      let grid = document.querySelector(gridName);
      if (grid) {
        this.gridName = gridName;
        this.gridContainer = grid;
        break;
      }
    }
  }
 
  init() {
    const observer = new IntersectionObserver(this.revealItem.bind(this), {
      root: null,
      threshold: 0.2, // Increased threshold for earlier trigger
      rootMargin: '200px' // Preload content 200px before it's visible
    });
    observer.observe(this);
  }
 
  fetchNextPage(e) {
    // Prevent multiple simultaneous requests
    if (this.isLoading || e > this.dataset.pageSize) {
      return;
    }
    
    this.isLoading = true;
    
    if (e <= this.dataset.pageSize) {
      const t = `{{ shop.url }}/${this.dataset.next}`;
      const i = new URL(t);
      i.searchParams.set("page", e);
      const r = i.href;
      
      // Use faster fetch with reduced timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
      
      fetch(`${r}`, { 
        method: "GET", 
        headers: { 
          "Content-Type": "text/html",
          "Cache-Control": "no-cache" // Ensure fresh content
        },
        signal: controller.signal
      })
        .then((response) => {
          clearTimeout(timeoutId);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.text();
        })
        .then((e) => {
          const t = new DOMParser().parseFromString(e, "text/html");
          const i = t.querySelector(this.gridName);
          if (i && i.innerHTML) {
            this.gridContainer.insertAdjacentHTML("beforeend", i.innerHTML);
          }
          this.isLoading = false;
        })
        .catch((e) => {
          clearTimeout(timeoutId);
          console.error("Error:", e);
          this.isLoading = false;
        });
    }
    
    if (e == this.dataset.pageSize) {
      this.innerHTML = `<h2>${this.dataset.endText}</h2>`;
    }
  }
  
  revealItem(e, t) {
    const [i] = e;
    if (!i.isIntersecting || this.isLoading) return;
    
    if (i.target) {
      this.page++;
      // Use setTimeout to make loading feel more responsive
      setTimeout(() => {
        this.fetchNextPage(this.page);
      }, 100);
    }
    
    if (this.page == this.dataset.pageSize) {
      t.unobserve(i.target);
    }
  }
  
  scrollToTopFx(e) {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
    e.currentTarget.style.display = "none";
  }
}
customElements.define("infinite-scroll", InfiniteScroll);
</script>